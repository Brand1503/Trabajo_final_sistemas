#include <Arduino.h>
#include <SPI.h>
#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>
#include <Keypad.h>

// Se declara un manejador de semáforo mutex que se va a usar para administrar el puerto serie.
// Se utiliza para garantizar que solo una Tarea acceda a este recurso en cualquier momento.
SemaphoreHandle_t xSemaforo_Pantalla;

int ruedaDelay;

TickType_t velocidadDelay;

#define SCREEN_WIDTH 128    // OLED display width, in pixels
#define SCREEN_HEIGHT 64    // OLED display height, in pixels
#define OLED_RESET -1       // Reset pin # (or -1 if sharing Arduino reset pin)
#define SCREEN_ADDRESS 0x3C ///< See datasheet for Address; 0x3D for 128x64, 0x3C for 128x32
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);
#define LOGO_HEIGHT 50
#define LOGO_WIDTH 50

void TaskSecuenciaLeds(void *pvParameters);
void TaskRueda(void *pvParameters);
void TaskVelocidad(void *pvParameters);
void TaskVelocidadLed(void *pvParameters);
void TaskCuadrado(void *pvParameters);


void setup()
{
  Serial.begin(115200);

  // Initial delay value
  velocidadDelay = 300 / portTICK_PERIOD_MS;

  // SSD1306_SWITCHCAPVCC = generate display voltage from 3.3V internally
  if (!display.begin(SSD1306_SWITCHCAPVCC, SCREEN_ADDRESS))
  {
    Serial.println(F("SSD1306 allocation failed"));
    for (;;)
      ; // Don't proceed, loop forever
  }

  display.clearDisplay();
  display.display();

  int midScreen = SCREEN_WIDTH / 2;
    display.drawRect(0, 0, midScreen, SCREEN_HEIGHT, SSD1306_WHITE);         // Left half
    display.drawRect(midScreen, 0, midScreen, SCREEN_HEIGHT, SSD1306_WHITE); // Right half

  if ( xSemaforo_Pantalla == NULL )  // Confirma que el semáforo del puerto serial aún no se ha creado.
  {
    xSemaforo_Pantalla = xSemaphoreCreateMutex();  // Se crea un semáforo mutex que se usa para administrar el puerto serial
    if ( ( xSemaforo_Pantalla ) != NULL )
      xSemaphoreGive( ( xSemaforo_Pantalla) );  // Hace que el puerto serie esté disponible para su uso, "Dando" el semáforo.
  }

  xTaskCreatePinnedToCore(
      TaskRueda
      , "Rueda"
      ,8192
      ,NULL// Stack siz,
      ,7
      ,NULL // Priority
      ,1);

  xTaskCreatePinnedToCore(
    TaskCuadrado
    ,"Cuadrado"
    , 8192
    ,NULL
    ,7
    ,NULL
    ,1);      

  // Now the task scheduler, which takes over control of scheduling individual tasks, is automatically started.
  xTaskCreatePinnedToCore(
      TaskSecuenciaLeds,
      "mi secuencia leds",
      1024, // Stack size
      NULL,
      3, // Priority
      NULL,
      0
  );

  xTaskCreatePinnedToCore(
      TaskVelocidadLed,
      "Velocidad Leds",
      4096,
      NULL,
      6,
      NULL,
      0
  );
  // Now the task scheduler, which takes over control of scheduling individual tasks, is automatically started.

  xTaskCreatePinnedToCore(
    TaskVelocidad
    ,"Velocidad Rueda"
    ,4096
    ,NULL
    ,5
    ,NULL
    ,1
  );
}

  

void loop()
{
  // Empty. Things are done in Tasks.
}

void TaskSecuenciaLeds(void *pvParameters) {
  (void)pvParameters;
  int posicion = 0;
  int leds[] = {19, 18, 5, 17, 16, 4};
  int k;

  for (k = 0; k < 6; ++k) {
    pinMode(leds[k], OUTPUT);
  }

  while (1) {
    for (k = 0; k < 2; ++k) {
      digitalWrite(leds[posicion], HIGH);
      digitalWrite(leds[posicion + 1], HIGH);
      vTaskDelay(velocidadDelay);
      digitalWrite(leds[posicion], LOW);
      digitalWrite(leds[posicion + 1], HIGH);
      vTaskDelay(velocidadDelay);
      digitalWrite(leds[posicion], HIGH);
      digitalWrite(leds[posicion + 1], LOW);
      vTaskDelay(velocidadDelay);
      digitalWrite(leds[posicion], LOW);
      digitalWrite(leds[posicion + 1], LOW);
    }
    posicion++;
    if (posicion > 4) {
      posicion = 0;
    }
    vTaskDelay(200 / portTICK_PERIOD_MS);
  }
}

void TaskVelocidadLed(void *pvParameters) {
  (void) pvParameters;
  int sensorValue;
  
  for(;;) {
    sensorValue = analogRead(39);
    velocidadDelay = (sensorValue * 3 + 100) / portTICK_PERIOD_MS;
    vTaskDelay(50 / portTICK_PERIOD_MS);
  }
}

void TaskRueda(void *pvParameters)
{
  (void)pvParameters;
  
  uint8_t rueda = 0;
  // 'wheel1', 50x50px
  const unsigned char epd_bitmap_wheel1[] PROGMEM = {
      0x00, 0x00, 0x03, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0x00, 0x00, 0x00, 0x00, 0x01,
      0xfc, 0x07, 0xe0, 0x00, 0x00, 0x00, 0x07, 0xc0, 0x00, 0x78, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00,
      0x1e, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00, 0x01, 0x80,
      0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0xe0, 0x00, 0x01, 0x80, 0x00, 0x00, 0x00, 0x60, 0x00, 0x03,
      0x00, 0x1f, 0xfe, 0x00, 0x30, 0x00, 0x07, 0x00, 0x7f, 0x3f, 0x80, 0x18, 0x00, 0x0e, 0x01, 0xe3,
      0x31, 0xe0, 0x1c, 0x00, 0x0c, 0x03, 0x83, 0x30, 0x70, 0x0e, 0x00, 0x18, 0x07, 0x03, 0x30, 0x38,
      0x06, 0x00, 0x18, 0x0e, 0x03, 0x30, 0x1c, 0x07, 0x00, 0x30, 0x0c, 0x03, 0x30, 0x0e, 0x03, 0x00,
      0x30, 0x18, 0x07, 0xfc, 0x07, 0x03, 0x00, 0x20, 0x38, 0x1f, 0x1e, 0x07, 0x01, 0x80, 0x60, 0x3e,
      0x38, 0x07, 0x1f, 0x81, 0x80, 0x60, 0x7f, 0xf0, 0x03, 0xff, 0x81, 0x80, 0x60, 0x61, 0xe0, 0x01,
      0xf1, 0x80, 0x80, 0x60, 0x60, 0xc0, 0x00, 0xc1, 0xc0, 0xc0, 0x40, 0x78, 0xc0, 0x00, 0xc3, 0xc0,
      0xc0, 0xc0, 0x7f, 0xc0, 0x00, 0x7f, 0xc0, 0xc0, 0xc0, 0xc7, 0xc0, 0x00, 0x7c, 0xc0, 0xc0, 0xc0,
      0xc1, 0xc0, 0x00, 0x60, 0xc0, 0xc0, 0xc0, 0x40, 0xc0, 0x00, 0x60, 0xc0, 0xc0, 0x40, 0x60, 0xc0,
      0x00, 0xc0, 0xc0, 0xc0, 0x60, 0x60, 0xc0, 0x00, 0xc0, 0xc0, 0xc0, 0x60, 0x60, 0x60, 0x01, 0xc1,
      0x80, 0x80, 0x60, 0x70, 0x70, 0x03, 0x81, 0x81, 0x80, 0x60, 0x30, 0x78, 0x07, 0xc3, 0x81, 0x80,
      0x20, 0x38, 0xde, 0x1e, 0xc3, 0x01, 0x80, 0x30, 0x19, 0xcf, 0xfc, 0x67, 0x03, 0x00, 0x30, 0x0f,
      0x8c, 0x0c, 0x7e, 0x03, 0x00, 0x18, 0x0f, 0x1c, 0x06, 0x3c, 0x07, 0x00, 0x18, 0x07, 0x18, 0x03,
      0x38, 0x06, 0x00, 0x0c, 0x03, 0xf0, 0x03, 0xf0, 0x0e, 0x00, 0x0e, 0x01, 0xf0, 0x01, 0xe0, 0x0c,
      0x00, 0x07, 0x00, 0x7c, 0x0f, 0x80, 0x18, 0x00, 0x03, 0x00, 0x1f, 0xfe, 0x00, 0x30, 0x00, 0x01,
      0x80, 0x01, 0xe0, 0x00, 0x70, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0xe0, 0x00, 0x00, 0x70, 0x00,
      0x00, 0x01, 0xc0, 0x00, 0x00, 0x38, 0x00, 0x00, 0x07, 0x80, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x1e,
      0x00, 0x00, 0x00, 0x07, 0x80, 0x00, 0x78, 0x00, 0x00, 0x00, 0x01, 0xf8, 0x07, 0xe0, 0x00, 0x00,
      0x00, 0x00, 0x3f, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x03, 0xf8, 0x00, 0x00, 0x00};
  // 'wheel2', 50x50px
  const unsigned char epd_bitmap_wheel2[] PROGMEM = {
      0x00, 0x00, 0x03, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0x00, 0x00, 0x00, 0x00, 0x01,
      0xf8, 0x07, 0xe0, 0x00, 0x00, 0x00, 0x07, 0xc0, 0x00, 0x78, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00,
      0x1e, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00, 0x03, 0x80,
      0x00, 0x00, 0xe0, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x01, 0x80, 0x00, 0x00, 0x00, 0x60, 0x00, 0x03,
      0x00, 0x1f, 0xfe, 0x00, 0x30, 0x00, 0x07, 0x00, 0x7e, 0x3f, 0x80, 0x38, 0x00, 0x0e, 0x01, 0xe0,
      0x33, 0xe0, 0x1c, 0x00, 0x0c, 0x03, 0x80, 0x63, 0xf0, 0x0c, 0x00, 0x1c, 0x07, 0x00, 0x63, 0x38,
      0x06, 0x00, 0x18, 0x0f, 0x00, 0x62, 0x1c, 0x06, 0x00, 0x30, 0x0f, 0x80, 0xe6, 0x0e, 0x03, 0x00,
      0x30, 0x19, 0xe7, 0xfe, 0x06, 0x03, 0x00, 0x30, 0x38, 0x7f, 0x1e, 0x03, 0x01, 0x00, 0x60, 0x3c,
      0x38, 0x07, 0x03, 0x01, 0x80, 0x60, 0x7e, 0x70, 0x03, 0x81, 0x81, 0x80, 0x60, 0x67, 0xe0, 0x01,
      0x81, 0x81, 0x80, 0x60, 0x61, 0xc0, 0x00, 0xc1, 0x81, 0x80, 0x60, 0x60, 0xc0, 0x00, 0xff, 0x80,
      0x80, 0x40, 0x40, 0xc0, 0x00, 0xff, 0xc0, 0xc0, 0x40, 0x40, 0xc0, 0x00, 0xe0, 0xc0, 0xc0, 0x40,
      0x40, 0xc0, 0x00, 0xc0, 0xc0, 0xc0, 0x40, 0x40, 0xc0, 0x00, 0xff, 0xc0, 0xc0, 0x60, 0x60, 0xc0,
      0x00, 0xff, 0x80, 0x80, 0x60, 0x61, 0xc0, 0x00, 0xc1, 0x81, 0x80, 0x60, 0x67, 0xe0, 0x01, 0x81,
      0x81, 0x80, 0x60, 0x7e, 0x70, 0x03, 0x81, 0x81, 0x80, 0x60, 0x3c, 0x38, 0x07, 0x03, 0x01, 0x80,
      0x30, 0x38, 0x7e, 0x1e, 0x03, 0x01, 0x00, 0x30, 0x18, 0xe7, 0xfe, 0x06, 0x03, 0x00, 0x30, 0x1f,
      0x80, 0xe6, 0x0e, 0x03, 0x00, 0x18, 0x0f, 0x00, 0x62, 0x1c, 0x06, 0x00, 0x1c, 0x07, 0x00, 0x63,
      0x38, 0x06, 0x00, 0x0c, 0x03, 0x80, 0x63, 0xf0, 0x0c, 0x00, 0x0e, 0x01, 0xe0, 0x31, 0xe0, 0x1c,
      0x00, 0x07, 0x00, 0x7c, 0x3f, 0x80, 0x38, 0x00, 0x03, 0x00, 0x1f, 0xfe, 0x00, 0x30, 0x00, 0x01,
      0x80, 0x01, 0xe0, 0x00, 0x60, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x70, 0x00,
      0x00, 0x03, 0x80, 0x00, 0x00, 0x38, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x1e,
      0x00, 0x00, 0x00, 0x07, 0x80, 0x00, 0x78, 0x00, 0x00, 0x00, 0x01, 0xf8, 0x07, 0xe0, 0x00, 0x00,
      0x00, 0x00, 0x3f, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xf8, 0x00, 0x00, 0x00};
  // 'wheel3', 50x50px
  const unsigned char epd_bitmap_wheel3[] PROGMEM = {
      0x00, 0x00, 0x03, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0x00, 0x00, 0x00, 0x00, 0x01,
      0xfc, 0x0f, 0xe0, 0x00, 0x00, 0x00, 0x07, 0x80, 0x00, 0xf8, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00,
      0x1e, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00, 0x03, 0x80,
      0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x01, 0x80, 0x00, 0x00, 0x00, 0x60, 0x00, 0x03,
      0x00, 0x1f, 0xfe, 0x00, 0x30, 0x00, 0x06, 0x00, 0x7c, 0x0f, 0x80, 0x38, 0x00, 0x0e, 0x01, 0xf0,
      0x03, 0xe0, 0x1c, 0x00, 0x0c, 0x03, 0xf0, 0x03, 0xf0, 0x0c, 0x00, 0x18, 0x07, 0x38, 0x07, 0x38,
      0x06, 0x00, 0x18, 0x0f, 0x18, 0x06, 0x3c, 0x06, 0x00, 0x30, 0x1f, 0x8c, 0x0c, 0x7e, 0x03, 0x00,
      0x30, 0x19, 0x8f, 0xfc, 0x66, 0x03, 0x00, 0x60, 0x30, 0xde, 0x3e, 0xc3, 0x01, 0x00, 0x60, 0x70,
      0xf8, 0x07, 0x83, 0x01, 0x80, 0x60, 0x60, 0x70, 0x03, 0x81, 0x81, 0x80, 0x60, 0x60, 0x60, 0x01,
      0x81, 0x81, 0x80, 0x40, 0x60, 0xc0, 0x00, 0xc1, 0x80, 0x80, 0xc0, 0xc0, 0xc0, 0x00, 0xc0, 0x80,
      0x80, 0xc0, 0xc1, 0x80, 0x00, 0xc0, 0xc0, 0xc0, 0xc0, 0xc1, 0x80, 0x00, 0xe0, 0xc0, 0xc0, 0xc0,
      0xc7, 0x80, 0x00, 0xf8, 0xc0, 0xc0, 0xc0, 0xff, 0x80, 0x00, 0xff, 0xc0, 0xc0, 0xc0, 0xf8, 0xc0,
      0x00, 0xc7, 0x80, 0x80, 0xc0, 0x60, 0xc0, 0x00, 0xc1, 0x80, 0x80, 0x60, 0x61, 0xe0, 0x01, 0xe1,
      0x81, 0x80, 0x60, 0x7f, 0xf0, 0x03, 0xff, 0x81, 0x80, 0x60, 0x7e, 0x38, 0x07, 0x1f, 0x01, 0x80,
      0x60, 0x38, 0x1e, 0x1e, 0x07, 0x01, 0x00, 0x30, 0x18, 0x0f, 0xf8, 0x06, 0x03, 0x00, 0x30, 0x1c,
      0x03, 0x70, 0x0e, 0x03, 0x00, 0x18, 0x0e, 0x03, 0x30, 0x1c, 0x06, 0x00, 0x18, 0x07, 0x03, 0x30,
      0x38, 0x06, 0x00, 0x0c, 0x03, 0x83, 0x30, 0x70, 0x0c, 0x00, 0x0e, 0x01, 0xe3, 0x31, 0xe0, 0x1c,
      0x00, 0x06, 0x00, 0x7f, 0x3f, 0x80, 0x18, 0x00, 0x03, 0x00, 0x1f, 0xfe, 0x00, 0x30, 0x00, 0x01,
      0x80, 0x01, 0xe0, 0x00, 0x60, 0x00, 0x01, 0xc0, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x60, 0x00,
      0x00, 0x03, 0x80, 0x00, 0x00, 0x38, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x1e,
      0x00, 0x00, 0x00, 0x07, 0x80, 0x00, 0x78, 0x00, 0x00, 0x00, 0x01, 0xf8, 0x07, 0xe0, 0x00, 0x00,
      0x00, 0x00, 0x3f, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xf0, 0x00, 0x00, 0x00};
  // 'wheel4', 50x50px
  const unsigned char epd_bitmap_wheel4[] PROGMEM = {
      0x00, 0x00, 0x03, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0x00, 0x00, 0x00, 0x00, 0x01,
      0xfc, 0x0f, 0xe0, 0x00, 0x00, 0x00, 0x07, 0x80, 0x00, 0x78, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00,
      0x1e, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0xe0, 0x00, 0x00, 0x03, 0x80,
      0x00, 0x01, 0xc0, 0x00, 0x00, 0x00, 0xe0, 0x00, 0x03, 0x80, 0x00, 0x00, 0x00, 0x60, 0x00, 0x07,
      0x00, 0x1f, 0xfe, 0x00, 0x30, 0x00, 0x06, 0x00, 0x7f, 0x0f, 0x80, 0x18, 0x00, 0x0c, 0x01, 0xf3,
      0x01, 0xe0, 0x1c, 0x00, 0x1c, 0x03, 0xf3, 0x00, 0x70, 0x0c, 0x00, 0x18, 0x07, 0x31, 0x80, 0x38,
      0x06, 0x00, 0x30, 0x0e, 0x31, 0x80, 0x3c, 0x07, 0x00, 0x30, 0x1c, 0x19, 0x80, 0x7e, 0x03, 0x00,
      0x30, 0x38, 0x1f, 0xf9, 0xe6, 0x03, 0x00, 0x60, 0x30, 0x1e, 0x1f, 0x87, 0x01, 0x80, 0x60, 0x70,
      0x38, 0x07, 0x0f, 0x01, 0x80, 0x60, 0x60, 0x70, 0x03, 0x9f, 0x81, 0x80, 0xc0, 0x60, 0xe0, 0x01,
      0xf9, 0x80, 0x80, 0xc0, 0x60, 0xc0, 0x00, 0xe1, 0x80, 0xc0, 0xc0, 0xff, 0xc0, 0x00, 0xc0, 0x80,
      0xc0, 0xc0, 0xff, 0x80, 0x00, 0x40, 0xc0, 0xc0, 0xc0, 0xc1, 0x80, 0x00, 0x60, 0xc0, 0xc0, 0xc0,
      0xc1, 0x80, 0x00, 0x60, 0xc0, 0xc0, 0xc0, 0xff, 0x80, 0x00, 0x40, 0xc0, 0xc0, 0xc0, 0xff, 0xc0,
      0x00, 0xc0, 0x80, 0xc0, 0xc0, 0x60, 0xc0, 0x00, 0xe1, 0x80, 0xc0, 0xc0, 0x60, 0xe0, 0x01, 0xf9,
      0x80, 0x80, 0x60, 0x60, 0x70, 0x03, 0x9f, 0x81, 0x80, 0x60, 0x60, 0x38, 0x07, 0x0f, 0x01, 0x80,
      0x60, 0x30, 0x1e, 0x1f, 0x87, 0x01, 0x80, 0x30, 0x38, 0x1f, 0xf9, 0xe6, 0x03, 0x00, 0x30, 0x1c,
      0x19, 0xc0, 0x7e, 0x03, 0x00, 0x30, 0x0c, 0x31, 0x80, 0x3c, 0x07, 0x00, 0x18, 0x07, 0x31, 0x80,
      0x38, 0x06, 0x00, 0x1c, 0x03, 0xf3, 0x00, 0x70, 0x0c, 0x00, 0x0c, 0x01, 0xf3, 0x01, 0xe0, 0x0c,
      0x00, 0x06, 0x00, 0x7f, 0x0f, 0x80, 0x18, 0x00, 0x07, 0x00, 0x1f, 0xfe, 0x00, 0x30, 0x00, 0x03,
      0x80, 0x01, 0xe0, 0x00, 0x60, 0x00, 0x01, 0xc0, 0x00, 0x00, 0x00, 0xe0, 0x00, 0x00, 0xe0, 0x00,
      0x00, 0x01, 0x80, 0x00, 0x00, 0x38, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x1e,
      0x00, 0x00, 0x00, 0x07, 0x80, 0x00, 0x78, 0x00, 0x00, 0x00, 0x01, 0xf8, 0x07, 0xe0, 0x00, 0x00,
      0x00, 0x00, 0x7f, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xf0, 0x00, 0x00, 0x00};

  // Array of all bitmaps for convenience. (Total bytes used to store images in PROGMEM = 1472)
  const int epd_bitmap_allArray_LEN = 4;
  const unsigned char *epd_bitmap_allArray[4] = {
      epd_bitmap_wheel1,
      epd_bitmap_wheel2,
      epd_bitmap_wheel3,
      epd_bitmap_wheel4};

  while (1)
  { if (xSemaphoreTake(xSemaforo_Pantalla, portMAX_DELAY) == pdTRUE){

  
    display.clearDisplay();

  // Draw the frame
    int midScreen = SCREEN_WIDTH / 2;
    display.drawRect(0, 0, midScreen, SCREEN_HEIGHT, SSD1306_WHITE);         // Left half
    display.drawRect(midScreen, 0, midScreen, SCREEN_HEIGHT, SSD1306_WHITE); // Right half

     // Dibuja la rueda
    display.drawBitmap(7, 7, epd_bitmap_allArray[rueda], 50, 50, SSD1306_WHITE);
    display.display();

    rueda = (rueda + 1) % 3;  // Alterna entre los tres bitmaps de la rueda

   xSemaphoreGive( xSemaforo_Pantalla);
  }
    vTaskDelay(ruedaDelay ); // Espera antes de actualizar la rueda
  }
}

void TaskCuadrado(void *pvParameters __attribute__((unused)) ){
  
  int rectWidth = 20;
  int rectHeight = 20;

  // Coordenadas del rectángulo
  int x = 85;
  int y = 20;
  

  
  while (1)
  { if ( xSemaphoreTake(xSemaforo_Pantalla, ( xSemaforo_Pantalla, portMAX_DELAY) == pdTRUE))
    {
  // Rellenar de afuera hacia adentro
  for(int i = 0; i <= rectWidth / 2; i++) {
    display.drawRect(x + i, y + i, rectWidth - 2 * i, rectHeight - 2 * i, SSD1306_WHITE);
    display.display();
  }
  // Vaciar de afuera hacia adentro
  for(int i = 0; i <= rectWidth / 2; i++) {
    display.drawRect(x + i, y + i, rectWidth - 2 * i, rectHeight - 2 * i, SSD1306_BLACK);
    display.display();
  }
  xSemaphoreGive( xSemaforo_Pantalla);
}
 vTaskDelay(100);
}  
}

void TaskVelocidad(void *pvParameters){
  (void)pvParameters;

  const byte ROWS = 4;
  const byte COLS = 4;
  char keys[ROWS][COLS] = {
    {'1', '2', '3', 'A'},
    {'4', '5', '6', 'B'},
    {'7', '8', '9', 'C'},
    {'*', '0', '#', 'D'}};
  byte rowPins[ROWS] = {33, 25, 26, 27}; // Filas
  byte colPins[COLS] = {14, 12, 13, 23}; // Columnas

  Keypad keypad(makeKeymap(keys), rowPins, colPins, ROWS, COLS);

  while (1)
  {
   char key = keypad.getKey();
    if (key != NO_KEY) {
        switch (key) {
        case '1':
            ruedaDelay = 10;
            break;
        case '2':
            ruedaDelay = 50;
            break;
        case '3':
            ruedaDelay = 120;
            break;    
        case '4':
            ruedaDelay = 250;
            break;
        case '5':
            ruedaDelay = 400;
            break;
        case '6':
            ruedaDelay = 500;
            break;
        case '7':
            ruedaDelay = 650;
            break;    
        case '8':
            ruedaDelay = 800;
            break;
        case '9':
            ruedaDelay = 1000;
            break;
        default:
            // Puedes dejar esto vacío o hacer algo aquí si una tecla no válida es presionada
            break;
        }
    }
  }

}
