#include <Arduino.h>
#include <SPI.h>
#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>
#include <Keypad.h>
#include <BluetoothSerial.h>
#include <freertos/FreeRTOS.h>
#include <freertos/task.h>

int ruedaDelay;

TickType_t velocidadDelay;

#define SCREEN_WIDTH 128    // OLED display width, in pixels
#define SCREEN_HEIGHT 64    // OLED display height, in pixels
#define OLED_RESET -1       // Reset pin # (or -1 if sharing Arduino reset pin)
#define SCREEN_ADDRESS 0x3C ///< See datasheet for Address; 0x3D for 128x64, 0x3C for 128x32
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);

#define LOGO_HEIGHT 50
#define LOGO_WIDTH 50

BluetoothSerial SerialBT;

TaskHandle_t id_TaskSecuenciaLedsHandle = NULL;
TaskHandle_t id_TaskRuedaHandle = NULL;
TaskHandle_t id_TaskVelocidadHandle = NULL;
TaskHandle_t id_TaskVelocidadLedHandle = NULL;
TaskHandle_t id_TaskBluetoothHandle = NULL;

void TaskSecuenciaLeds(void *pvParameters);
void TaskRueda(void *pvParameters);
void TaskVelocidad(void *pvParameters);
void TaskVelocidadLed(void *pvParameters);
void TaskBluetooth(void *pvParameters);

void setup()
{
  Serial.begin(115200);
  SerialBT.begin("ESP32_LED_Display_Control"); // Nombre del dispositivo Bluetooth
  Serial.println("El dispositivo estÃ¡ listo para emparejarse.");
  // Initial delay value
  velocidadDelay = 300 / portTICK_PERIOD_MS;

  // SSD1306_SWITCHCAPVCC = generate display voltage from 3.3V internally
  if (!display.begin(SSD1306_SWITCHCAPVCC, SCREEN_ADDRESS))
  {
    Serial.println(F("SSD1306 allocation failed"));
    for (;;)
      ; // Don't proceed, loop forever
  }
  display.display();
  vTaskDelay(2000 / portTICK_PERIOD_MS);
  display.clearDisplay();

  xTaskCreatePinnedToCore(
      TaskRueda
      , "Rueda"
      ,4096
      ,NULL// Stack siz,
      ,4
      ,&id_TaskRuedaHandle // Priority
      ,0);

  // Now the task scheduler, which takes over control of scheduling individual tasks, is automatically started.
  xTaskCreatePinnedToCore(
      TaskSecuenciaLeds,
      "mi secuencia leds",
      1024, // Stack size
      NULL,
      3, // Priority
      &id_TaskSecuenciaLedsHandle,
      0
  );

  xTaskCreatePinnedToCore(
      TaskVelocidadLed,
      "Velocidad Leds",
      4096,
      NULL,
      6,
      &id_TaskVelocidadLedHandle,
      0
  );
  // Now the task scheduler, which takes over control of scheduling individual tasks, is automatically started.

  xTaskCreatePinnedToCore(
    TaskVelocidad
    ,"Velocidad Rueda"
    ,4096
    ,NULL
    ,5
    ,&id_TaskVelocidadHandle
    ,1
  );
  xTaskCreatePinnedToCore(
    TaskBluetooth
  , "TaskBluetooth"
  , 2048
  , NULL
  , 10
  , &id_TaskBluetoothHandle
  , 1);

}

void loop()
{
  // Empty. Things are done in Tasks.
}

void TaskSecuenciaLeds(void *pvParameters) {
  (void)pvParameters;
  int posicion = 0;
  int leds[] = {19, 18, 5, 17, 16, 4};
  int k;

  for (k = 0; k < 6; ++k) {
    pinMode(leds[k], OUTPUT);
  }

  while (1) {
    for (k = 0; k < 2; ++k) {
      digitalWrite(leds[posicion], HIGH);
      digitalWrite(leds[posicion + 1], HIGH);
      vTaskDelay(velocidadDelay);
      digitalWrite(leds[posicion], LOW);
      digitalWrite(leds[posicion + 1], HIGH);
      vTaskDelay(velocidadDelay);
      digitalWrite(leds[posicion], HIGH);
      digitalWrite(leds[posicion + 1], LOW);
      vTaskDelay(velocidadDelay);
      digitalWrite(leds[posicion], LOW);
      digitalWrite(leds[posicion + 1], LOW);
    }
    posicion++;
    if (posicion > 4) {
      posicion = 0;
    }
    vTaskDelay(200 / portTICK_PERIOD_MS);
  }
}

void TaskVelocidadLed(void *pvParameters) {
  (void) pvParameters;
  int sensorValue;
  
  for(;;) {
    sensorValue = analogRead(39);
    velocidadDelay = (sensorValue * 3 + 100) / portTICK_PERIOD_MS;
    vTaskDelay(50 / portTICK_PERIOD_MS);
  }
}

void TaskRueda(void *pvParameters)
{
  (void)pvParameters;
  
  uint8_t rueda = 0;
  // 'wheel1', 50x50px
  const unsigned char epd_bitmap_wheel1[] PROGMEM = {
      0x00, 0x00, 0x03, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0x00, 0x00, 0x00, 0x00, 0x01,
      0xfc, 0x07, 0xe0, 0x00, 0x00, 0x00, 0x07, 0xc0, 0x00, 0x78, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00,
      0x1e, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00, 0x01, 0x80,
      0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0xe0, 0x00, 0x01, 0x80, 0x00, 0x00, 0x00, 0x60, 0x00, 0x03,
      0x00, 0x1f, 0xfe, 0x00, 0x30, 0x00, 0x07, 0x00, 0x7f, 0x3f, 0x80, 0x18, 0x00, 0x0e, 0x01, 0xe3,
      0x31, 0xe0, 0x1c, 0x00, 0x0c, 0x03, 0x83, 0x30, 0x70, 0x0e, 0x00, 0x18, 0x07, 0x03, 0x30, 0x38,
      0x06, 0x00, 0x18, 0x0e, 0x03, 0x30, 0x1c, 0x07, 0x00, 0x30, 0x0c, 0x03, 0x30, 0x0e, 0x03, 0x00,
      0x30, 0x18, 0x07, 0xfc, 0x07, 0x03, 0x00, 0x20, 0x38, 0x1f, 0x1e, 0x07, 0x01, 0x80, 0x60, 0x3e,
      0x38, 0x07, 0x1f, 0x81, 0x80, 0x60, 0x7f, 0xf0, 0x03, 0xff, 0x81, 0x80, 0x60, 0x61, 0xe0, 0x01,
      0xf1, 0x80, 0x80, 0x60, 0x60, 0xc0, 0x00, 0xc1, 0xc0, 0xc0, 0x40, 0x78, 0xc0, 0x00, 0xc3, 0xc0,
      0xc0, 0xc0, 0x7f, 0xc0, 0x00, 0x7f, 0xc0, 0xc0, 0xc0, 0xc7, 0xc0, 0x00, 0x7c, 0xc0, 0xc0, 0xc0,
      0xc1, 0xc0, 0x00, 0x60, 0xc0, 0xc0, 0xc0, 0x40, 0xc0, 0x00, 0x60, 0xc0, 0xc0, 0x40, 0x60, 0xc0,
      0x00, 0xc0, 0xc0, 0xc0, 0x60, 0x60, 0xc0, 0x00, 0xc0, 0xc0, 0xc0, 0x60, 0x60, 0x60, 0x01, 0xc1,
      0x80, 0x80, 0x60, 0x70, 0x70, 0x03, 0x81, 0x81, 0x80, 0x60, 0x30, 0x78, 0x07, 0xc3, 0x81, 0x80,
      0x20, 0x38, 0xde, 0x1e, 0xc3, 0x01, 0x80, 0x30, 0x19, 0xcf, 0xfc, 0x67, 0x03, 0x00, 0x30, 0x0f,
      0x8c, 0x0c, 0x7e, 0x03, 0x00, 0x18, 0x0f, 0x1c, 0x06, 0x3c, 0x07, 0x00, 0x18, 0x07, 0x18, 0x03,
      0x38, 0x06, 0x00, 0x0c, 0x03, 0xf0, 0x03, 0xf0, 0x0e, 0x00, 0x0e, 0x01, 0xf0, 0x01, 0xe0, 0x0c,
      0x00, 0x07, 0x00, 0x7c, 0x0f, 0x80, 0x18, 0x00, 0x03, 0x00, 0x1f, 0xfe, 0x00, 0x30, 0x00, 0x01,
      0x80, 0x01, 0xe0, 0x00, 0x70, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0xe0, 0x00, 0x00, 0x70, 0x00,
      0x00, 0x01, 0xc0, 0x00, 0x00, 0x38, 0x00, 0x00, 0x07, 0x80, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x1e,
      0x00, 0x00, 0x00, 0x07, 0x80, 0x00, 0x78, 0x00, 0x00, 0x00, 0x01, 0xf8, 0x07, 0xe0, 0x00, 0x00,
      0x00, 0x00, 0x3f, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x03, 0xf8, 0x00, 0x00, 0x00};
  // 'wheel2', 50x50px
  const unsigned char epd_bitmap_wheel2[] PROGMEM = {
      0x00, 0x00, 0x03, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0x00, 0x00, 0x00, 0x00, 0x01,
      0xf8, 0x07, 0xe0, 0x00, 0x00, 0x00, 0x07, 0xc0, 0x00, 0x78, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00,
      0x1e, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00, 0x03, 0x80,
      0x00, 0x00, 0xe0, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x01, 0x80, 0x00, 0x00, 0x00, 0x60, 0x00, 0x03,
      0x00, 0x1f, 0xfe, 0x00, 0x30, 0x00, 0x07, 0x00, 0x7e, 0x3f, 0x80, 0x38, 0x00, 0x0e, 0x01, 0xe0,
      0x33, 0xe0, 0x1c, 0x00, 0x0c, 0x03, 0x80, 0x63, 0xf0, 0x0c, 0x00, 0x1c, 0x07, 0x00, 0x63, 0x38,
      0x06, 0x00, 0x18, 0x0f, 0x00, 0x62, 0x1c, 0x06, 0x00, 0x30, 0x0f, 0x80, 0xe6, 0x0e, 0x03, 0x00,
      0x30, 0x19, 0xe7, 0xfe, 0x06, 0x03, 0x00, 0x30, 0x38, 0x7f, 0x1e, 0x03, 0x01, 0x00, 0x60, 0x3c,
      0x38, 0x07, 0x03, 0x01, 0x80, 0x60, 0x7e, 0x70, 0x03, 0x81, 0x81, 0x80, 0x60, 0x67, 0xe0, 0x01,
      0x81, 0x81, 0x80, 0x60, 0x61, 0xc0, 0x00, 0xc1, 0x81, 0x80, 0x60, 0x60, 0xc0, 0x00, 0xff, 0x80,
      0x80, 0x40, 0x40, 0xc0, 0x00, 0xff, 0xc0, 0xc0, 0x40, 0x40, 0xc0, 0x00, 0xe0, 0xc0, 0xc0, 0x40,
      0x40, 0xc0, 0x00, 0xc0, 0xc0, 0xc0, 0x40, 0x40, 0xc0, 0x00, 0xff, 0xc0, 0xc0, 0x60, 0x60, 0xc0,
      0x00, 0xff, 0x80, 0x80, 0x60, 0x61, 0xc0, 0x00, 0xc1, 0x81, 0x80, 0x60, 0x67, 0xe0, 0x01, 0x81,
      0x81, 0x80, 0x60, 0x7e, 0x70, 0x03, 0x81, 0x81, 0x80, 0x60, 0x3c, 0x38, 0x07, 0x03, 0x01, 0x80,
      0x30, 0x38, 0x7e, 0x1e, 0x03, 0x01, 0x00, 0x30, 0x18, 0xe7, 0xfe, 0x06, 0x03, 0x00, 0x30, 0x1f,
      0x80, 0xe6, 0x0e, 0x03, 0x00, 0x18, 0x0f, 0x00, 0x62, 0x1c, 0x06, 0x00, 0x1c, 0x07, 0x00, 0x63,
      0x38, 0x06, 0x00, 0x0c, 0x03, 0x80, 0x63, 0xf0, 0x0c, 0x00, 0x0e, 0x01, 0xe0, 0x31, 0xe0, 0x1c,
      0x00, 0x07, 0x00, 0x7c, 0x3f, 0x80, 0x38, 0x00, 0x03, 0x00, 0x1f, 0xfe, 0x00, 0x30, 0x00, 0x01,
      0x80, 0x01, 0xe0, 0x00, 0x60, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x70, 0x00,
      0x00, 0x03, 0x80, 0x00, 0x00, 0x38, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x1e,
      0x00, 0x00, 0x00, 0x07, 0x80, 0x00, 0x78, 0x00, 0x00, 0x00, 0x01, 0xf8, 0x07, 0xe0, 0x00, 0x00,
      0x00, 0x00, 0x3f, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0xf8, 0x00, 0x00, 0x00};
  // 'wheel3', 50x50px
  const unsigned char epd_bitmap_wheel3[] PROGMEM = {
      0x00, 0x00, 0x03, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0x00, 0x00, 0x00, 0x00, 0x01,
      0xfc, 0x0f, 0xe0, 0x00, 0x00, 0x00, 0x07, 0x80, 0x00, 0xf8, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00,
      0x1e, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00, 0x03, 0x80,
      0x00, 0x00, 0xc0, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x01, 0x80, 0x00, 0x00, 0x00, 0x60, 0x00, 0x03,
      0x00, 0x1f, 0xfe, 0x00, 0x30, 0x00, 0x06, 0x00, 0x7c, 0x0f, 0x80, 0x38, 0x00, 0x0e, 0x01, 0xf0,
      0x03, 0xe0, 0x1c, 0x00, 0x0c, 0x03, 0xf0, 0x03, 0xf0, 0x0c, 0x00, 0x18, 0x07, 0x38, 0x07, 0x38,
      0x06, 0x00, 0x18, 0x0f, 0x18, 0x06, 0x3c, 0x06, 0x00, 0x30, 0x1f, 0x8c, 0x0c, 0x7e, 0x03, 0x00,
      0x30, 0x19, 0x8f, 0xfc, 0x66, 0x03, 0x00, 0x60, 0x30, 0xde, 0x3e, 0xc3, 0x01, 0x00, 0x60, 0x70,
      0xf8, 0x07, 0x83, 0x01, 0x80, 0x60, 0x60, 0x70, 0x03, 0x81, 0x81, 0x80, 0x60, 0x60, 0x60, 0x01,
      0x81, 0x81, 0x80, 0x40, 0x60, 0xc0, 0x00, 0xc1, 0x80, 0x80, 0xc0, 0xc0, 0xc0, 0x00, 0xc0, 0x80,
      0x80, 0xc0, 0xc1, 0x80, 0x00, 0xc0, 0xc0, 0xc0, 0xc0, 0xc1, 0x80, 0x00, 0xe0, 0xc0, 0xc0, 0xc0,
      0xc7, 0x80, 0x00, 0xf8, 0xc0, 0xc0, 0xc0, 0xff, 0x80, 0x00, 0xff, 0xc0, 0xc0, 0xc0, 0xf8, 0xc0,
      0x00, 0xc7, 0x80, 0x80, 0xc0, 0x60, 0xc0, 0x00, 0xc1, 0x80, 0x80, 0x60, 0x61, 0xe0, 0x01, 0xe1,
      0x81, 0x80, 0x60, 0x7f, 0xf0, 0x03, 0xff, 0x81, 0x80, 0x60, 0x7e, 0x38, 0x07, 0x1f, 0x01, 0x80,
      0x60, 0x38, 0x1e, 0x1e, 0x07, 0x01, 0x00, 0x30, 0x18, 0x0f, 0xf8, 0x06, 0x03, 0x00, 0x30, 0x1c,
      0x03, 0x70, 0x0e, 0x03, 0x00, 0x18, 0x0e, 0x03, 0x30, 0x1c, 0x06, 0x00, 0x18, 0x07, 0x03, 0x30,
      0x38, 0x06, 0x00, 0x0c, 0x03, 0x83, 0x30, 0x70, 0x0c, 0x00, 0x0e, 0x01, 0xe3, 0x31, 0xe0, 0x1c,
      0x00, 0x06, 0x00, 0x7f, 0x3f, 0x80, 0x18, 0x00, 0x03, 0x00, 0x1f, 0xfe, 0x00, 0x30, 0x00, 0x01,
      0x80, 0x01, 0xe0, 0x00, 0x60, 0x00, 0x01, 0xc0, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x60, 0x00,
      0x00, 0x03, 0x80, 0x00, 0x00, 0x38, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x1e,
      0x00, 0x00, 0x00, 0x07, 0x80, 0x00, 0x78, 0x00, 0x00, 0x00, 0x01, 0xf8, 0x07, 0xe0, 0x00, 0x00,
      0x00, 0x00, 0x3f, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xf0, 0x00, 0x00, 0x00};
  // 'wheel4', 50x50px
  const unsigned char epd_bitmap_wheel4[] PROGMEM = {
      0x00, 0x00, 0x03, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0x00, 0x00, 0x00, 0x00, 0x01,
      0xfc, 0x0f, 0xe0, 0x00, 0x00, 0x00, 0x07, 0x80, 0x00, 0x78, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00,
      0x1e, 0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0xe0, 0x00, 0x00, 0x03, 0x80,
      0x00, 0x01, 0xc0, 0x00, 0x00, 0x00, 0xe0, 0x00, 0x03, 0x80, 0x00, 0x00, 0x00, 0x60, 0x00, 0x07,
      0x00, 0x1f, 0xfe, 0x00, 0x30, 0x00, 0x06, 0x00, 0x7f, 0x0f, 0x80, 0x18, 0x00, 0x0c, 0x01, 0xf3,
      0x01, 0xe0, 0x1c, 0x00, 0x1c, 0x03, 0xf3, 0x00, 0x70, 0x0c, 0x00, 0x18, 0x07, 0x31, 0x80, 0x38,
      0x06, 0x00, 0x30, 0x0e, 0x31, 0x80, 0x3c, 0x07, 0x00, 0x30, 0x1c, 0x19, 0x80, 0x7e, 0x03, 0x00,
      0x30, 0x38, 0x1f, 0xf9, 0xe6, 0x03, 0x00, 0x60, 0x30, 0x1e, 0x1f, 0x87, 0x01, 0x80, 0x60, 0x70,
      0x38, 0x07, 0x0f, 0x01, 0x80, 0x60, 0x60, 0x70, 0x03, 0x9f, 0x81, 0x80, 0xc0, 0x60, 0xe0, 0x01,
      0xf9, 0x80, 0x80, 0xc0, 0x60, 0xc0, 0x00, 0xe1, 0x80, 0xc0, 0xc0, 0xff, 0xc0, 0x00, 0xc0, 0x80,
      0xc0, 0xc0, 0xff, 0x80, 0x00, 0x40, 0xc0, 0xc0, 0xc0, 0xc1, 0x80, 0x00, 0x60, 0xc0, 0xc0, 0xc0,
      0xc1, 0x80, 0x00, 0x60, 0xc0, 0xc0, 0xc0, 0xff, 0x80, 0x00, 0x40, 0xc0, 0xc0, 0xc0, 0xff, 0xc0,
      0x00, 0xc0, 0x80, 0xc0, 0xc0, 0x60, 0xc0, 0x00, 0xe1, 0x80, 0xc0, 0xc0, 0x60, 0xe0, 0x01, 0xf9,
      0x80, 0x80, 0x60, 0x60, 0x70, 0x03, 0x9f, 0x81, 0x80, 0x60, 0x60, 0x38, 0x07, 0x0f, 0x01, 0x80,
      0x60, 0x30, 0x1e, 0x1f, 0x87, 0x01, 0x80, 0x30, 0x38, 0x1f, 0xf9, 0xe6, 0x03, 0x00, 0x30, 0x1c,
      0x19, 0xc0, 0x7e, 0x03, 0x00, 0x30, 0x0c, 0x31, 0x80, 0x3c, 0x07, 0x00, 0x18, 0x07, 0x31, 0x80,
      0x38, 0x06, 0x00, 0x1c, 0x03, 0xf3, 0x00, 0x70, 0x0c, 0x00, 0x0c, 0x01, 0xf3, 0x01, 0xe0, 0x0c,
      0x00, 0x06, 0x00, 0x7f, 0x0f, 0x80, 0x18, 0x00, 0x07, 0x00, 0x1f, 0xfe, 0x00, 0x30, 0x00, 0x03,
      0x80, 0x01, 0xe0, 0x00, 0x60, 0x00, 0x01, 0xc0, 0x00, 0x00, 0x00, 0xe0, 0x00, 0x00, 0xe0, 0x00,
      0x00, 0x01, 0x80, 0x00, 0x00, 0x38, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x1e,
      0x00, 0x00, 0x00, 0x07, 0x80, 0x00, 0x78, 0x00, 0x00, 0x00, 0x01, 0xf8, 0x07, 0xe0, 0x00, 0x00,
      0x00, 0x00, 0x7f, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xf0, 0x00, 0x00, 0x00};

  // Array of all bitmaps for convenience. (Total bytes used to store images in PROGMEM = 1472)
  const int epd_bitmap_allArray_LEN = 4;
  const unsigned char *epd_bitmap_allArray[4] = {
      epd_bitmap_wheel1,
      epd_bitmap_wheel2,
      epd_bitmap_wheel3,
      epd_bitmap_wheel4};

  while (1)
  {
    display.clearDisplay();

    // Draw the frame
    int midScreen = SCREEN_WIDTH / 2;
    display.drawRect(0, 0, midScreen, SCREEN_HEIGHT, SSD1306_WHITE);         // Left half
    display.drawRect(midScreen, 0, midScreen, SCREEN_HEIGHT, SSD1306_WHITE); // Right half

    // Draw the wheel image in the left half
    switch (rueda)
    {
    case 0:
      display.drawBitmap(7, (SCREEN_HEIGHT - LOGO_HEIGHT) / 2, epd_bitmap_wheel1, LOGO_WIDTH, LOGO_HEIGHT, SSD1306_WHITE);
      rueda = 1;
      break;
    case 1:
      display.drawBitmap(7, (SCREEN_HEIGHT - LOGO_HEIGHT) / 2, epd_bitmap_wheel2, LOGO_WIDTH, LOGO_HEIGHT, SSD1306_WHITE);
      rueda = 2;
      break;
    case 2:
      display.drawBitmap(7, (SCREEN_HEIGHT - LOGO_HEIGHT) / 2, epd_bitmap_wheel3, LOGO_WIDTH, LOGO_HEIGHT, SSD1306_WHITE);
      rueda = 0;
      break;
    }
    display.display();
    vTaskDelay(ruedaDelay); // puedo controlar la velocidad de la rueda esto debo cambiar con el teclado
  }
}

void TaskVelocidad(void *pvParameters){
  (void)pvParameters;

  const byte ROWS = 4;
  const byte COLS = 4;
  char keys[ROWS][COLS] = {
    {'1', '2', '3', 'A'},
    {'4', '5', '6', 'B'},
    {'7', '8', '9', 'C'},
    {'*', '0', '#', 'D'}};
  byte rowPins[ROWS] = {33, 25, 26, 27}; // Filas
  byte colPins[COLS] = {14, 12, 13, 23}; // Columnas

  Keypad keypad(makeKeymap(keys), rowPins, colPins, ROWS, COLS);

  while (1)
  {
   char key = keypad.getKey();
    if (key != NO_KEY) {
        switch (key) {
        case '1':
            ruedaDelay = 10;
            break;
        case '2':
            ruedaDelay = 50;
            break;
        case '3':
            ruedaDelay = 100;
            break;    
        case '4':
            ruedaDelay = 150;
            break;
        case '5':
            ruedaDelay = 200;
            break;
        case '6':
            ruedaDelay = 250;
            break;
        case '7':
            ruedaDelay = 300;
            break;    
        case '8':
            ruedaDelay = 350;
            break;
        case '9':
            ruedaDelay = 400;
            break;
        default:
            // Puedes dejar esto vacÃ­o o hacer algo aquÃ­ si una tecla no vÃ¡lida es presionada
            break;
        }
    }
    vTaskDelay (50);
  }

}

void TaskBluetooth(void *pvParameters) {
  (void) pvParameters;
  
  while (true) {
    if (SerialBT.available()) {
      char cmd = SerialBT.read();
      Serial.print("Comando recibido: ");
      Serial.println(cmd);
      
      switch(cmd) {
        case 's':
          vTaskSuspend(id_TaskSecuenciaLedsHandle);  // Suspend LED task
          vTaskSuspend(id_TaskRuedaHandle);  // Suspend display task
          vTaskSuspend(id_TaskVelocidadHandle);
          vTaskSuspend(id_TaskVelocidadLedHandle);
          break;
        case 'r':
          vTaskResume(id_TaskSecuenciaLedsHandle);  // Suspend LED task
          vTaskResume(id_TaskRuedaHandle);  // Suspend display task
          vTaskResume(id_TaskVelocidadHandle);
          vTaskResume(id_TaskVelocidadLedHandle);
          break;
      }
    }
    vTaskDelay(50); // Delay to prevent task from using too much CPU
  }
}
